from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator

class Profile(models.Model):
    # Choices for gender field
    GENDER_CHOICES = [
        ('M', 'Male'),
        ('F', 'Female')
    ]

    # Choices for relationship status
    RELATIONSHIP_STATUS_CHOICES = [
        ('S', 'Single'),
        ('D', 'Divorced'),
        ('W', 'Widowed'),
    ]

    # Choices for what the user is looking for
    LOOKING_FOR_CHOICES = [
        ('LO', 'Long-term'),
        ('SH', 'Short-term'),
        ('FR', 'Friendship'),
        ('CA', 'Casual'),
    ]

    # Basic personal information
    name = models.CharField(max_length=100, help_text="Enter your full name")
    age = models.IntegerField(
        validators=[MinValueValidator(18), MaxValueValidator(100)],
        help_text="Enter your age (must be between 18 and 100)"
    )
    gender = models.CharField(
        max_length=1, 
        choices=GENDER_CHOICES,
        help_text="Select your gender"
    )

    # Relationship information
    relationship_status = models.CharField(
        max_length=1, 
        choices=RELATIONSHIP_STATUS_CHOICES,
        help_text="Select your current relationship status"
    )
    looking_for = models.CharField(
        max_length=2, 
        choices=LOOKING_FOR_CHOICES,
        help_text="Select what kind of relationship you're looking for"
    )
    settle_timeline = models.IntegerField(
        validators=[MinValueValidator(0), MaxValueValidator(60)],
        help_text="Enter your timeline to settle down in months (0-60)"
    )

    # Professional and personal interests
    occupation = models.CharField(
        max_length=100,
        help_text="Enter your current occupation"
    )
    interests = models.TextField(
        blank=True,
        help_text="Enter your interests, separated by commas"
    )

    # Timestamp fields for record keeping
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.name} ({self.age})"

    def get_looking_for_display(self):
        """
        Returns the full display text for what the user is looking for.
        This is useful for readability in the admin interface and templates.
        """
        return dict(self.LOOKING_FOR_CHOICES).get(self.looking_for, '')

    class Meta:
        ordering = ['-created_at']  # Orders profiles with the newest first by default

class Match(models.Model):
    profile1 = models.ForeignKey(
        Profile, 
        on_delete=models.CASCADE,
        related_name='matches_as_profile1',
        help_text="The first profile in the match"
    )
    profile2 = models.ForeignKey(
        Profile, 
        on_delete=models.CASCADE,
        related_name='matches_as_profile2',
        help_text="The second profile in the match"
    )
    compatibility_score = models.FloatField(
        validators=[MinValueValidator(0), MaxValueValidator(100)],
        help_text="The compatibility score between the two profiles (0-100)"
    )
    reason = models.TextField(
        help_text="The reason for the match, generated by the system"
    )
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Match between {self.profile1.name} and {self.profile2.name}"

    class Meta:
        verbose_name_plural = "Matches"
        ordering = ['-compatibility_score', '-created_at']

# Usage:
# from .models import Profile, Match
#
# # Create a new profile
# new_profile = Profile.objects.create(
#     name="John Doe",
#     age=30,
#     gender="M",
#     relationship_status="S",
#     looking_for="LT",
#     settle_timeline=24,
#     occupation="Software Developer",
#     interests="Hiking, Reading, Cooking"
# )
#
# # Create a new match
# new_match = Match.objects.create(
#     profile1=profile1,
#     profile2=profile2,
#     compatibility_score=85.5,
#     reason="Both enjoy outdoor activities and have similar career goals."
# )